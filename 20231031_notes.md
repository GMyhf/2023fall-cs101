# 2023/10/31 Tuesday 读题和递归

Updated 1716 GMT+8 Oct 27 2023

2020 fall, Complied by Hongfei Yan



目录：



# 读题 

## 545C. Woodcutters

dp/greedy, 1500, https://codeforces.com/problemset/problem/545/C

Little Susie listens to fairy tales before bed every day. Today's fairy tale was about wood cutters and the little girl immediately started imagining the choppers cutting wood. She imagined the situation that is described below.

There are *n* trees located along the road at points with coordinates *x*~1~, *x*~2~, ..., *x~n~*. Each tree has its height *h~i~*. Woodcutters can cut down a tree and fell it to the left or to the right. After that it occupies one of the segments [*x~i~* - *h~i~*, *x~i~*] or [*x~i~*;*x~i~* + *h~i~*]. The tree that is not cut down occupies a single point with coordinate *x~i~*. Woodcutters can fell a tree if the segment to be occupied by the fallen tree doesn't contain any occupied point. The woodcutters want to process as many trees as possible, so Susie wonders, what is the maximum number of trees to fell.

**Input**

The first line contains integer *n* (1 ≤ *n* ≤ 10^5^) — the number of trees.

Next *n* lines contain pairs of integers *x~i~*, *h~i~* (1 ≤ *x~i~*, *h~i~* ≤ 10^9^) — the coordinate and the height of the *і*-th tree.

The pairs are given in the order of ascending *x~i~*. No two trees are located at the point with the same coordinate.

**Output**

Print a single number — the maximum number of trees that you can cut down by the given rules.

Examples

input

```
5
1 2
2 1
5 10
10 9
19 1
```

output

```
3
```

input

```
5
1 2
2 1
5 10
10 9
20 1
```

output

```
4
```

Note

In the first sample you can fell the trees like that:

- fell the 1-st tree to the left — now it occupies segment [ - 1;1]
- fell the 2-nd tree to the right — now it occupies segment [2;3]
- leave the 3-rd tree — it occupies point 5
- leave the 4-th tree — it occupies point 10
- fell the 5-th tree to the right — now it occupies segment [19;20]

In the second sample you can also fell 4-th tree to the right, after that it will occupy segment [10;19].



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20231026190820436.png" alt="image-20231026190820436" style="zoom:50%;" />



## 1793C. Dora and Search

constructive algorithms, data structures, two pointers, 1200, 

https://codeforces.com/problemset/problem/1793/C

As you know, the girl Dora is always looking for something. This time she was given a permutation, and she wants to find such a subsegment of it that none of the elements at its ends is either the minimum or the maximum of the entire subsegment. More formally, you are asked to find the numbers 𝑙 and 𝑟 (1≤𝑙≤𝑟≤𝑛) such that $𝑎𝑙≠min(𝑎_𝑙,𝑎_{𝑙+1},…,𝑎_𝑟)$, $𝑎𝑙≠max(𝑎_𝑙,𝑎_{𝑙+1},…,𝑎_𝑟)$ and $𝑎𝑟≠min(𝑎_𝑙,𝑎_{𝑙+1},…,𝑎_𝑟)$, $𝑎𝑟≠max(𝑎_𝑙,𝑎_{𝑙+1},…,𝑎_𝑟)$.

A permutation of length 𝑛 is an array consisting of 𝑛 distinct integers from 11 to 𝑛 in any order. For example, \[2,3,1,5,4] is a permutation, but \[1,2,2] is not a permutation (2 occurs twice in the array) and \[1,3,4][1,3,4] is also not a permutation (𝑛=3, but 4 is present in the array).

Help Dora find such a subsegment, or tell her that such a subsegment does not exist.

**Input**

Each test consists of multiple test cases. The first line contains a single integer $𝑡 (1≤𝑡≤10^4)$ — the number of test cases. Description of the test cases follows.

For each test case, the first line contains one integer $𝑛(1≤𝑛≤2⋅10^5)$ — the length of permutation.

The second line contains 𝑛 distinct integers $𝑎_1,𝑎_2,…,𝑎_𝑛 (1≤𝑎_𝑖≤𝑛)$ — the elements of permutation.

It is guarented that the sum of 𝑛 over all test cases doesn't exceed 2⋅1052⋅105.

**Output**

For each test case, output −1−1 if the desired subsegment does not exist.

Otherwise, output two indexes 𝑙,𝑟 such that $[𝑎_𝑙,𝑎_{𝑙+1},…,𝑎_𝑟]$ satisfies all conditions.

If there are several solutions, then output any of them.

Example

input

```
4
3
1 2 3
4
2 1 4 3
7
1 3 2 4 6 5 7
6
2 3 6 5 4 1
```

output

```
-1
1 4
2 6
-1
```

Note

In the first and fourth test cases, it can be shown that there are no desired subsegments.

In the second test case, the subsegment \[1,4] satisfies all the conditions, because $max(𝑎_1,𝑎_2,𝑎_3,𝑎_4)=4,min(𝑎_1,𝑎_2,𝑎_3,𝑎_4)=1$, as we see, all the conditions are met.

In the third test case, the subsegment \[2,6] also satisfies all the conditions described.



<img src="/Users/hfyan/Library/Application Support/typora-user-images/image-20231026190955752.png" alt="image-20231026190955752" style="zoom:50%;" />





**数学思维**

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20231026102551375.png" alt="image-20231026102551375" style="zoom:50%;" />



https://baike.baidu.com/item/戴德金原理/18881836

戴德金原理（Dedekind principle）亦称[戴德金分割](https://baike.baidu.com/item/戴德金分割/6095064?fromModule=lemma_inlink)，是保证直线连续性的基础，其内容为：如果把直线的所有点分成两类，使得：1.每个点恰属于一个类，每个类都不空。2.第一类的每个点都在第二类的每个点的前面，那么，或者在第一类里存在着这样的点，第一类中所有其余的点都在它的前面；或者在第二类里存在着这样的点，它在第二类的所有其余的点的前面 [3]。这个点决定直线的戴德金割切，此点称为戴德金点(或界点)，戴德金原理是戴德金((J.W.)R.Dedekind)于1872年提出来的，在构造欧氏几何的公理系统时，可以选取它作为连续公理，在希尔伯特公理组Ⅰ，Ⅱ，Ⅲ的基础上，[阿基米德公理](https://baike.baidu.com/item/阿基米德公理/1797603?fromModule=lemma_inlink)和康托尔公理合在一起与戴德金原理等价。



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20231026103418567.png" alt="image-20231026103418567" style="zoom:50%;" />



https://zhuanlan.zhihu.com/p/528662514?utm_id=0

图兰定理（Turan's graph theorem）图论（graph theory）的一条基本定理，它是极值图论（extremal graph theory）的开端。此定理有很多种证明方法，我们将要介绍其中的五个。在陈述图兰定理前，我们先介绍一些背景知识。令 G 为一个简单图（simple graph），即不包含多重边（multiple edges）也不包含自环（loop）。令 G 的顶点（vertex）集为 $V={v_1,...,v_n}$，边（edge）集为 E。若一个图的每对顶点都被唯一的一条边相连，则成此图为一个完全图（complete graph），而一个图的完全子图（complete subgraph）叫作团（clique）。我们将包含 p 的顶点的 p-团写作$K_p$。



## 803A. Maximal Binary Matrix

constructive algorithms, 1400, https://codeforces.com/problemset/problem/803/A

You are given matrix with *n* rows and *n* columns filled with zeroes. You should put *k* ones in it in such a way that the resulting matrix is symmetrical with respect to the main diagonal (the diagonal that goes from the top left to the bottom right corner) and is lexicographically maximal.

One matrix is lexicographically greater than the other if the first different number in the first different row from the top in the first matrix is greater than the corresponding number in the second one.

If there exists no such matrix then output -1.

**Input**

The first line consists of two numbers *n* and *k* (1 ≤ *n* ≤ 100, 0 ≤ *k* ≤ 106).

**Output**

If the answer exists then output resulting matrix. Otherwise output -1.

Examples

input

```
2 1
```

output

```
1 0 
0 0 
```

input

```
3 2
```

output

```
1 0 0 
0 1 0 
0 0 0 
```

input

```
2 5
```

output

```
-1
```



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20231026190632627.png" alt="image-20231026190632627" style="zoom:50%;" />



## 题目都有背景知识

### 12560: 生存游戏

matrices, http://cs101.openjudge.cn/practice/12560/

有如下生存游戏的规则：

给定一个n*m(1<=n,m<=100)的数组，每个元素代表一个细胞，其初始状态为活着(1)或死去(0)。

每个细胞会与其相邻的8个邻居（除数组边缘的细胞）进行交互，并遵守如下规则：

任何一个活着的细胞如果只有小于2个活着的邻居，那它就会由于人口稀少死去。

任何一个活着的细胞如果有2个或者3个活着的邻居，就可以继续活下去。

任何一个活着的细胞如果有超过3个活着的邻居，那它就会由于人口拥挤而死去。

任何一个死去的细胞如果有恰好3个活着的邻居，那它就会由于繁殖而重新变成活着的状态。



请写一个函数用来计算所给定初始状态的细胞经过一次更新后的状态是什么。

注意：所有细胞的状态必须同时更新，不能使用更新后的状态作为其他细胞的邻居状态来进行计算。

**输入**

第一行为n和m，而后n行，每行m个元素，用空格隔开。

**输出**

n行，每行m个元素，用空格隔开。

样例输入

```
3 4
0 0 1 1
1 1 0 0
1 1 0 1
```

样例输出

```
0 1 1 0
1 0 0 1
1 1 1 0
```

来源：cs10116 final exam



康威生命游戏(Game of Life)  https://baike.baidu.com/item/康威生命游戏/22668799?fr=ge_ala

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20231026190204167.png" alt="image-20231026190204167" style="zoom: 50%;" />



细胞自动机

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20231026190253685.png" alt="image-20231026190253685" style="zoom:50%;" />



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20231026190315997.png" alt="image-20231026190315997" style="zoom:50%;" />



# Cantor Expansion



## 康托展开(Cantor)

给出一个数N，再给出N的全排列中的某一个排列，问该排列在所有全排列中的次序是多少（按字典序排序，例如3的全排列中，123排第1位，321排最后一位）。
Input
第1行为一个数N(N＜20)，第2行为N的全排列中的某一个排列。
Output
一个整数，表示该排列在全排列中的次序。
Sample in
3
1 2 3
Sample out
1

思路：最容易想到的方法是把所有排列求出来后再进行排序，但事实上有更简单高效的算法来解决这个问题，那就是康托展开式，即把一个整数X展开成如下形式：
$X＝a[n]×(n-1)!＋a[n-1]×(n-2)!＋…＋a[i]×(i-1)!＋…＋a[2]×1!＋a[1]×0!$
其中a[i]表示当前数在未出现过的元素中是排在第几个。
例如求5 2 3 4 1在{1,2,3,4,5}生成的排列中的次序可以按如下步骤计算。
第1位是5，比5小的数有1、2、3、4这4个数，所以有4×4！。
第2位是2，比2小的数有1一个数，所以有1×3！。
第3位是3，比3小的数有1、2两个数，因为2在前面已经出现过了，所以只有一个数，为1×2！。
第4位是4，比4小的数有1、2、3这3个数，因为2、3在前面已经出现过了，所以只有一个数，为1×1！。
最后一位数无论是几，比它小的数在前面肯定都出现了，所以为0×0！＝0。
则4×4！＋1×3！＋1×2！＋1×1！＝105。
简化后的算式为 (((((4×4)＋1)×3)＋1)×2＋1)×1＝105。
这个X只是这个排列之前的排列数，而题目要求这个排列的位置，即52341排在第106位。

同理，4 3 5 2 1的排列数：3×4!＋2×3!＋2×2!＋1×1!＝89，即43521排在第90位。
因为比4小的数有3个：3、2、1；比3小的数有2个：2、1；比5小的数有2个：2、1；比2小的数有1个：1。
其简化算式为(((((3×4)＋2)×3)＋2)×2＋1)×1＝89。

参考代码如下。



![image-20231026114956764](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20231026114956764.png)



```c++
// cantor expansion
#include<bits/stdc++.h>
using namespace std;

int a[50];

long long Cantor(int s[],int n)
{
  bool used[50] = {0};
  long long ans = 0;
  for(int i = n; i >= 1; i--)
  {
    int NoUse = 0;
    used[s[n - i]] = true;
    for(int j = 0; j < s[n - i]; j++)      //search number used
      if(used[j])
        NoUse++;
    ans= (ans + s[n - i] - NoUse) * i;     //computing cantor expansion
  }
  return ans+1;
}

int main()
{
  //freopen("cantor.in","r",stdin);
  //freopen("cantor.out","w",stdout);
  int N;
  cin >> N;
  for (int i=1; i<=N; i++)
    cin >> a[i];
  cout << Cantor(a,N) << endl;
  return 0;
}
```

进一步的优化是使用树状数组或线段树（找已用过的数的数量）。



## 康托展开逆运算(cantor 2)

给出一个数N，再给出N的全排列的某一个排列的次序数，输出该排列。
**Input**
第1行为一个数N(N≤9)，第2行为N的全排列的某一个排列的次序数。

**Output**

一行字符串，即该排列。
Sample in
3
1
Sample out
123



思路：可以用康托展开的逆运算来求解。假设已有{1,2,3,4,5}的全排列，并且已经从小到大排序完毕，现要找出第96个数的排列是什么，则康托展开逆运算的具体计算过程如下：
首先用96-1得到95；
用95去除4! 得到3余23，商为3表示有3个数比它小，则该数是4，所以第1位是4；
用23去除3! 得到3余5，商为3，表示有3个数比它小，即该数是4，但4前面已经出现过了，所以第2位是5；
用5去除2!得到2余1，商为2，表示有2个数比它小，即该数是3，所以第3位是3；
用1去除1!得到1余0，表示有1个数比它小，即该数是2，所以第4位是2；
最后一个数只能是1。
所以这个排列是45321。
又如找出第16个数的排列的计算过程如下：
首先用16-1得到15；
用15去除4!得到0余15，表示有0个数比它小，即该数是1，第1位是1；
用15去除3!得到2余3，表示有2个数比它小，即该数是3，但由于1已经在之前出现过了，所以第2位是4（因为1在之前出现过了，所以实际上比4小的数是2）；
用3去除2!得到1余1，表示有1个数比它小，即该数是2，但由于1已经在之前出现过了，所以第3位是3（因为1在之前出现过了，所以实际上比3小的数是1）；
用1去除1!得到1余0，表示有1个数比它小，即该数是2，但由于1、3、4已经在之前出现过了，所以第4位是5（因为1、3、4在之前出现过了，所以实际上比5小的数是1）。
最后一个数只能是2，所以这个数是14352。
参考代码如下。

![image-20231026150633258](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20231026150633258.png)



```c++
//康托展开逆运算
#include <bits/stdc++.h>
using namespace std;

int fac[10]= {1,1,2,6,24,120,720,5040,40320,362880};   //预处理求出阶乘的值
int Hash[10];

int Cantor(int m,int n)
{
  int num=0;
  int used,digit;
  m--;
  for(int i=n-1; i>0; i--)
  {
    used=0;
    digit=m/fac[i]+1;                               //计算有几个数比它小后加1
    m%=fac[i];                                      //更新m
    for(int j=1; j<=used+digit; j++)                //查找之前有哪些数已被用过
      if(Hash[j])
        used++;
    num += (used+digit)*pow(10,i);
    Hash[used + digit]=1;                             //标记该数被使用过
  }
  for(int i=1; i<=n; i++)                           //取出最后的未被使用的数
    if(Hash[i] == 0)
      return num+i;

  return -1;
}

int main()
{
  //freopen("cantor2.in","r",stdin);
  //freopen("cantor2.out","w",stdout);
  int num,n;
  cin >> num >> n;
  printf("%d\n",Cantor(n,num));
  return 0;
}
```





## 01833: 排列

Math, http://cs101.openjudge.cn/practice/01833

大家知道，给出正整数n，则1到n这n个数可以构成n！种排列，把这些排列按照从小到大的顺序（字典顺序）列出，如 n=3 时，列出1 2 3，1 3 2，2 1 3，2 3 1，3 1 2，3 2 1六个排列。

任务描述：
给出某个排列，求出这个排列的下k个排列，如果遇到最后一个排列，则下1排列为第1个排列，即排列1 2 3…n。
比如：n = 3，k=2 给出排列2 3 1，则它的下1个排列为3 1 2，下2个排列为3 2 1，因此答案为3 2 1。

**输入**

第一行是一个正整数m，表示测试数据的个数，下面是m组测试数据，每组测试数据第一行是2个正整数n( 1 <= n < 1024 )和k(1<=k<=64)，第二行有n个正整数，是1，2 … n的一个排列。

**输出**

对于每组输入数据，输出一行，n个数，中间用空格隔开，表示输入排列的下k个排列。

样例输入

```
3
3 1
2 3 1
3 1
3 2 1
10 2	
1 2 3 4 5 6 7 8 9 10
```

样例输出

```
3 1 2
1 2 3
1 2 3 4 5 6 7 9 8 10
```

来源

qinlu@POJ



这三个题目是相同的，tags: two pointers

01833:排列

http://cs101.openjudge.cn/practice/01833/

02996:选课

http://cs101.openjudge.cn/practice/02996/

31.下一个排列

https://leetcode.cn/problems/next-permutation/



    # 计算阶乘
    aa = [1]
    for i in range(1, n+1):
        aa.append(aa[-1] * i)
    
    # 初始化 bb 和 pos（bb中每个元素的位置）
    pos = [0] * (n+1)
    bb = list(OrderedDict.fromkeys(range(1, n+1)))

```python
# 2022fall-cs101，陈勃宇
# cantor expansion

aa = [1]
c = 1
for i in range(1,1025):
    c = c * i
    aa.append(c)

for _ in range(int(input())):
    n,k = map(int,input().split())
    *cc, = map(int,input().split())
    *bb, = range(1,n + 1)
    
    d = 0
    l = n - 1
    for j in cc:
        d = d + bb.index(j) * aa[l]
        bb.remove(j)
        l -= 1
    
    d += k
    while d >= aa[n]:
        d -= aa[n]
        
    dd = []
    *bb, = range(1,n + 1)
    for p in range(n - 1,-1,-1):
        t = d // aa[p]
        dd.append(bb[t])
        del(bb[t])
        d -= t * aa[p]
    print(*dd)
```



## P5367 【模板】康托展开

https://www.luogu.com.cn/problem/P5367

求 $1\sim N$ 的一个给定全排列在所有 $1\sim N$ 全排列中的排名。结果对 $998244353$ 取模。

Input

第一行一个正整数 $N$。

第二行 $N$ 个正整数，表示 $1\sim N$ 的一种全排列。

Output

一行一个非负整数，表示答案对 $998244353$ 取模的值。

Sample1 in

```
3
2 1 3
```

Sample1 out

```
3
```

Sample2 in

```
4
1 2 4 3
```

Sample2 out

```
2
```

提示

对于$10\%$数据，$1\le N\le 10$。

对于$50\%$数据，$1\le N\le 5000$。

对于$100\%$数据，$1\le N\le 1000000$。



线段树 segment tree 来计算第i位右边比该数还要小的数的个数。

![image-20231027152504779](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20231027152504779.png)



```python
import array as arr
n = int(input())

# Max size of tree
tree = arr.array('i', [0] * (2 * n))


def build(arr):

    # insert leaf nodes in tree
    for i in range(n):
        tree[n + i] = arr[i]

    # build the tree by calculating parents
    for i in range(n - 1, 0, -1):
        tree[i] = tree[i << 1] + tree[i << 1 | 1]


# function to update a tree node
def updateTreeNode(p, value):

    # set value at position p
    tree[p + n] = value
    p = p + n

    # move upward and update parents
    i = p

    while i > 1:

        tree[i >> 1] = tree[i] + tree[i ^ 1]
        i >>= 1


# function to get sum on interval [l, r)
def query(l, r):

    res = 0

    # loop to find the sum in the range
    l += n
    r += n

    while l < r:

        if (l & 1):
            res += tree[l]
            l += 1

        if (r & 1):
            r -= 1
            res += tree[r]

        l >>= 1
        r >>= 1

    return res


build([1]*n)
#print(tree)


wyx = 998244353

fac = [1, 1] + [0]*n
for i in range(1, n + 1):
    fac[i] = (fac[i - 1] * i) % wyx

ans = 0

a = list(map(int, input().split()))
for i in range(1, n + 1):
    #print(a[i-1], query(0,a[i-1])-1)
    ans = (ans + (query(0, a[i-1]) - 1) * fac[n - i]) % wyx
    #print(ans)
    updateTreeNode(a[i-1]-1, 0)

print(ans + 1)

```

用pypy提交，还是超内存。

![image-20231027152739418](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20231027152739418.png)





![image-20231026120849593](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20231026120849593.png)



![image-20231026120917808](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20231026120917808.png)



```python
import array as arr
n = int(input())
#tree = [0] * (n + 5)
tree = arr.array('i', [0] * (n + 5))
#tree = [0] * 1000005

def lowbit(x):
    return x & -x

def update(x, y):
    while x <= n:
        tree[x] += y
        x += lowbit(x)

def query(x):
    sum = 0
    while x:
        sum += tree[x]
        x -= lowbit(x)
    return sum

wyx = 998244353
#jc = [1, 1]
#jc = [1,1] + [0]*1000003
#jc = [1,1] + [0]*(n+3)
jc = arr.array('i', [1,1] + [0] * (n + 3))

for i in range(1, n + 1):
    #jc.append((jc[i - 1] * i) % wyx)
    jc[i] = (jc[i - 1] * i) % wyx
    update(i, 1)

ans = 0

a = list(map(int, input().split()))
#a = [0] + a
a = arr.array('i', [0] + a)
for i in range(1, n + 1):
    #a[i] = int(input())
    ans = (ans + ((query(a[i]) - 1) * jc[n - i]) % wyx) % wyx
    update(a[i], -1)

print(ans + 1)
```



![image-20231026174532512](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20231026174532512.png)



这段代码是实现树状数组的核心部分，包括了三个重要的操作：lowbit、修改和求和。

1. lowbit函数：`lowbit(x)` 是用来计算 `x` 的二进制表示中最低位的 `1` 所对应的值。它的运算规则是利用位运算 `(x & -x)` 来获取 `x` 的最低位 `1` 所对应的值。例如，`lowbit(6)` 的结果是 `2`，因为 `6` 的二进制表示为 `110`，最低位的 `1` 所对应的值是 `2`。

2. update函数：这个函数用于修改树状数组中某个位置的值。参数 `x` 表示要修改的位置，参数 `y` 表示要增加/减少的值。函数使用一个循环将 `x` 的所有对应位置上的值都加上 `y`。具体的操作是首先将 `x` 位置上的值与 `y` 相加，然后通过 `lowbit` 函数找到 `x` 的下一个需要修改的位置，将该位置上的值也加上 `y`，然后继续找下一个位置，直到修改完所有需要修改的位置为止。这样就完成了数组的修改。

3. query函数：这个函数用于求解树状数组中某个范围的前缀和。参数 `x` 表示要求解前缀和的位置。函数使用一个循环将 `x` 的所有对应位置上的值累加起来，然后通过 `lowbit` 函数找到 `x` 的上一个位置（即最后一个需要累加的位置），再将该位置上的值累加起来，然后继续找上一个位置，直到累加完所有需要累加的位置为止。这样就得到了从位置 `1` 到位置 `x` 的前缀和。

这就是树状数组的核心操作，通过使用这三个函数，我们可以实现树状数组的各种功能，如求解区间和、单点修改等。希望能对您有所帮助。如果您对其中的某个部分还有疑惑，可以继续询问。

```c++
#include<iostream>
#include<cstdio>
using namespace std;
typedef long long ll;//虽然不知道这题不开long long会不会见祖宗，但保险起见还是开一下吧
ll tree[1000005];//树状数组
int n;
  //树状数组的“老三件”：lowbit，修改，求和
int lowbit(int x){
	return x&-x;
}
void update(int x,int y){
	while(x<=n){
		tree[x]+=y;
		x+=lowbit(x);	
	}
}
ll query(int x){
	ll sum=0;
	while(x){
		sum+=tree[x];
		x-=lowbit(x);	
	}
	return sum;
}
const ll wyx=998244353;//懒人专用
ll jc[1000005]={1,1};//存阶乘的数组
int a[1000005];//存数的
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){//预处理阶乘数组和树状数组
		jc[i]=(jc[i-1]*i)%wyx;
		update(i,1);
	}
	ll ans=0;
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		ans=(ans+((query(a[i])-1)*jc[n-i])%wyx)%wyx;//计算ans
		update(a[i],-1);//把a[i]变成0（原来是1，减1不就是0嘛）
	}
	printf("%lld",ans+1);//别忘了+1
   return /*2333333333*/ 0;
}
```



如何使用python中的高效数组，array类详解

https://baijiahao.baidu.com/s?id=1770291275843443574&wfr=spider&for=pc

```python
import sys
import array

a = array.array('i', [0]*1000000)
size = sys.getsizeof(a)//(1024*1024) + 1

print(f'signed int: {size}MB')

b = [0]*1000000
size = sys.getsizeof(b)//(1024*1024) + 1
print(f'list: {size}MB')

for code in array.typecodes:
    arr = array.array(code)
    print(code, arr.itemsize)
```

```
signed int: 4MB
list: 8MB
b 1
B 1
u 4
h 2
H 2
i 4
I 4
l 8
L 8
q 8
Q 8
f 4
d 8
```





# 递归





# 语法

在Python中，执行删除操作通常建议使用logic删除，而不是physic删除。也就是说，不直接从列表中删除元素，而是标记它已经删除了。删除操作消耗的时间更少。

布尔代数（Boolean Algebra）是一种数学上的代数系统，用于处理逻辑运算和关系。它涉及布尔值（true和false）以及与、或、非等逻辑运算符。在逻辑删除中，布尔代数的概念被用于标记和操作数据行的删除状态，因此可以说逻辑删除涉及布尔代数的使用。

> 布尔代数
> 世界上不可能有比二进制更简单的计数方法了，它只有两个数字:0和1。从单纯数学的角度讲，它甚至比我们的十进制更合理。但是我们人有十个手指，使用起来比二进制(或者八进制)方便得多，所以在进化和文明发展过程中人类采用了十进制。二进制的历史其实也很早，中国古代的阴阳学说可以认为是最早二进制的雏形。而二进制作为一个计数系统公元前 2-5 世纪时由印度学者完成，但是他们没有使用0和 1计数。到17 世纪，德国伟大的数学家莱布尼兹(Gottfried Leibniz)把它完善，并且用0和 1表示它的两个数字，成为我们今天使用的二进制。二进制除了是一种计数的方式外，它还可以表示逻辑的“是”与“非”。这第二个特性在索引中非常有用。布尔运算是针对二进制，尤其是二进制第二个特性的运算，它很简单，可能没有比布尔运算更简单的运算了。尽管今天每个搜索引擎都官称自己如何聪明、多么智能(这个词非常忽悠人)其实从根本上讲都没有逃出布尔运算的框框。
> 布尔( George Boole)是19 世纪英国的一位中学数学老师，还创办过一所中学。后来在爱尔兰科克( Cork)的一所学院当教授。生前没有人认为他是数学家，虽然他曾经在剑桥大学数学杂志( Cambridge Mathematical Journal)上发表过论文。(英国另一位生前没有被公认为科学家的是著名物理学家焦耳，虽然他生前已经是英国皇家科学院院士，但是他的公认身份是啤酒商。)布尔在工作之余，喜欢阅读数学论著，思考数学问题。1854 年，布尔的《思维规律》(An Investigation ofthe Laws of Thought, on which are founded the Mathematical Theories ofLogic and Probabilities)一书，第一次向人们展示了如何用数学的方法解决逻辑问题。在此之前，人们普遍的认识是数学和逻辑是两个不同的学科今天联合国教科文组织依然把它们严格分开。
> 布尔代数简单得不能再简单了。运算的元素只有两个:1(TRUE，真 )和0(FALSE，假)。基本的运算只有“与”(AND)、“或”(OR)和“非”(NOT) 三种(后来发现，这三种运算都可以转换成“与非”AND-NOT 一种运算)。全部运算只用下列几张真值表就能完全描述清楚。
>
> 表 8.1 与运算真值表
>
> | AND  | 1    | 0    |
> | ---- | ---- | ---- |
> | 1    | 1    | 0    |
> | 0    | 0    | 0    |
>
> 
>
> 表 8.1 说明，如果 AND 运算的两个元素有一个是 0，则运算结果总是 0。如果两个元素都是 1，运算结果是 1。例如，“太阳从西边升起”这个判断是假的(0)，“水可以流动”这个判断是真的(1)，那么，“太阳从西边升起并且水可以流动”就是假的(0)。
>
> 表 8.2 或运算真值表
>
> | OR   | 1    | 0    |
> | ---- | ---- | ---- |
> | 1    | 1    | 1    |
> | 0    | 1    | 0    |
>
>
> 表 8.2 说明，如果 OR 运算的两个元素有一个是 1，则运算结果总是 1。
>
> 如果两个元素都是 0，则运算结果是 0。比如说，“张三是比赛第一名“李四是比赛第一名”是真的(1)，那么“张这个结论是假的(0) 三或者李四是第一名”就是真的(1)。
>
> 表8.3非运算真值表
>
> | NOT  |      |
> | ---- | ---- |
> | 1    | 0    |
> | 0    | 1    |
>
> 
>
> 表 8.3 说明，NOT 运算把 1变成 0，把0变成 1。比如，如果“象牙是白的”是真的(1)，那么“象牙不是白的”必定是假的(0)。
> 这么简单的理论能解决什么实际问题。和布尔同时代的数学家们也有同样的疑问。事实上，在布尔代数提出后 80 多年里，它确实没有什么像样的应用，直到 1938 年香农在他的硕士论文中指出用布尔代数来实现开关电路，才使得布尔代数成为数字电路的基础。所有的数学和逻辑运算，加、减、乘、除、乘方、开方等等，全都能转换成二值的布尔运算。数学的发展实际上是不断地抽象和概括的过程，这些抽象了的方法看似离生活越来越远，但是它们最终能找到适用的地方，布尔代数便是如此。
>
> if控制语句在程序中用于根据条件的真假来进行逻辑推理和计算，并根据条件的结果选择性地执行特定的代码块。，就是逻辑推理与计算合二为一。

 







OrderedDict。但是Python标准库中的OrderedDict删除元素的复杂度是O(1)。

from collections import OrderedDict

for _ in range(int(input())):
    n, k = map(int, input().split())
    cc = list(map(int, input().split()))
    



# 数据结构

## Segment tree | Efficient implementation

https://www.geeksforgeeks.org/segment-tree-efficient-implementation/

Let us consider the following problem to understand Segment Trees without recursion.
We have an array arr[0 . . . n-1]. We should be able to, 

1. Find the sum of elements from index l to r where 0 <= l <= r <= n-1
2. Change the value of a specified element of the array to a new value x. We need to do arr[i] = x where 0 <= i <= n-1. 

A **simple solution** is to run a loop from l to r and calculate the sum of elements in the given range. To update a value, simply do arr[i] = x. The first operation takes **O(n)** time and the second operation takes **O(1)** time.

**Another solution** is to create another array and store the sum from start to i at the ith index in this array. The sum of a given range can now be calculated in O(1) time, but the update operation takes O(n) time now. This works well if the number of query operations is large and there are very few updates.
What if the number of queries and updates are equal? Can we perform both the operations in O(log n) time once given the array? We can use a [Segment Tree](https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/) to do both operations in O(Logn) time. We have discussed the complete implementation of segment trees in our [previous](https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/) post. In this post, we will discuss the easier and yet efficient implementation of segment trees than in the previous post.
Consider the array and segment tree as shown below: 

![img](https://media.geeksforgeeks.org/wp-content/uploads/excl.png)



You can see from the above image that the original array is at the bottom and is 0-indexed with 16 elements. The tree contains a total of 31 nodes where the leaf nodes or the elements of the original array start from node 16. So, we can easily construct a segment tree for this array using a 2*N sized array where N is the number of elements in the original array. The leaf nodes will start from index N in this array and will go up to index (2*N – 1). Therefore, the element at index i in the original array will be at index (i + N) in the segment tree array. Now to calculate the parents, we will start from the index (N – 1) and move upward. For index i , the left child will be at (2 * i) and the right child will be at (2*i + 1) index. So the values at nodes at (2 * i) and (2*i + 1) are combined at i-th node to construct the tree. 
As you can see in the above figure, we can query in this tree in an interval [L,R) with left index(L) included and right (R) excluded.
We will implement all of these multiplication and addition operations using bitwise operators.
Let us have a look at the complete implementation: 

```python
# Python3 Code Addition 

# limit for array size 
N = 100000; 

# Max size of tree 
tree = [0] * (2 * N); 

# function to build the tree 
def build(arr) : 

	# insert leaf nodes in tree 
	for i in range(n) : 
		tree[n + i] = arr[i]; 
	
	# build the tree by calculating parents 
	for i in range(n - 1, 0, -1) : 
		tree[i] = tree[i << 1] + tree[i << 1 | 1]; 

# function to update a tree node 
def updateTreeNode(p, value) : 
	
	# set value at position p 
	tree[p + n] = value; 
	p = p + n; 
	
	# move upward and update parents 
	i = p; 
	
	while i > 1 : 
		
		tree[i >> 1] = tree[i] + tree[i ^ 1]; 
		i >>= 1; 

# function to get sum on interval [l, r) 
def query(l, r) : 

	res = 0; 
	
	# loop to find the sum in the range 
	l += n; 
	r += n; 
	
	while l < r : 
	
		if (l & 1) : 
			res += tree[l]; 
			l += 1
	
		if (r & 1) : 
			r -= 1; 
			res += tree[r]; 
			
		l >>= 1; 
		r >>= 1
	
	return res; 

# Driver Code 
if __name__ == "__main__" : 

	a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]; 

	# n is global 
	n = len(a); 
	
	# build tree 
	build(a); 
	
	# print the sum in range(1,2) index-based 
	print(query(1, 3)); 
	
	# modify element at 2nd index 
	updateTreeNode(2, 1); 
	
	# print the sum in range(1,2) index-based 
	print(query(1, 3)); 
	
# This code is contributed by AnkitRai01 

```



**Output:** 

```
5
3
```

Yes! That is all. The complete implementation of the segment tree includes the query and update functions in a lower number of lines of code than the previous recursive one. Let us now understand how each of the functions works: 


1. The picture makes it clear that the leaf nodes are stored at i+n, so we can clearly insert all leaf nodes directly.
2. The next step is to build the tree and it takes O(n) time. The parent always has its less index than its children, so we just process all the nodes in decreasing order, calculating the value of the parent node. If the code inside the build function to calculate parents seems confusing, then you can see this code. It is equivalent to that inside the build function. 

```
tree[i]=tree[2*i]+tree[2*i+1]
```

 

3. Updating a value at any position is also simple and the time taken will be proportional to the height of the tree. We only update values in the parents of the given node which is being changed. So to get the parent, we just go up to the parent node, which is p/2 or p>>1, for node p. p^1 turns (2*i) to (2*i + 1) and vice versa to get the second child of p.
4. Computing the sum also works in O(log(n)) time. If we work through an interval of [3,11), we need to calculate only for nodes 19,26,12, and 5 in that order.

The idea behind the query function is whether we should include an element in the sum or whether we should include its parent. Let’s look at the image once again for proper understanding. Consider that L is the left border of an interval and R is the right border of the interval [L,R). It is clear from the image that if L is odd, then it means that it is the right child of its parent and our interval includes only L and not the parent. So we will simply include this node to sum and move to the parent of its next node by doing L = (L+1)/2. Now, if L is even, then it is the left child of its parent and the interval includes its parent also unless the right borders interfere. Similar conditions are applied to the right border also for faster computation. We will stop this iteration once the left and right borders meet.
The theoretical time complexities of both previous implementation and this implementation is the same, but practically, it is found to be much more efficient as there are no recursive calls. We simply iterate over the elements that we need. Also, this is very easy to implement.

**Time Complexities:**

- Tree Construction: O( n )
- Query in Range: O( Log n )
- Updating an element: O( Log n ).

**Auxiliary Space:** O(2*N)



## 1364A: A. XXXXX

brute force/data structures/number theory/two pointers, 1200, https://codeforces.com/problemset/problem/1364/A

Ehab loves number theory, but for some reason he hates the number 𝑥. Given an array 𝑎, find the length of its longest subarray such that the sum of its elements **isn't** divisible by 𝑥, or determine that such subarray doesn't exist.

An array 𝑎 is a subarray of an array 𝑏 if 𝑎 can be obtained from 𝑏 by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

**Input**

The first line contains an integer 𝑡 (1≤𝑡≤5) — the number of test cases you need to solve. The description of the test cases follows.

The first line of each test case contains 2 integers 𝑛 and 𝑥 (1≤𝑛≤10^5^, 1≤𝑥≤10^4^) — the number of elements in the array 𝑎 and the number that Ehab hates.

The second line contains 𝑛 space-separated integers $𝑎_1, 𝑎_2, ……, 𝑎_𝑛 (0≤𝑎_𝑖≤10^4)$ — the elements of the array 𝑎.

**Output**

For each testcase, print the length of the longest subarray whose sum isn't divisible by 𝑥. If there's no such subarray, print −1.

Example

input

```
3
3 3
1 2 3
3 4
1 2 3
2 2
0 6
```

output

```
2
3
-1
```

Note

In the first test case, the subarray \[2,3\] has sum of elements 5, which isn't divisible by 3.

In the second test case, the sum of elements of the whole array is 6, which isn't divisible by 4.

In the third test case, all subarrays have an even sum, so the answer is −1.



Pypy3 可以AC。使用tree segment，时间复杂度是O(n*logn)

```python
# CF 1364A
 
# def prefix_sum(nums):
#     prefix = []
#     total = 0
#     for num in nums:
#         total += num
#         prefix.append(total)
#     return prefix
 
# def suffix_sum(nums):
#     suffix = []
#     total = 0
#     # 首先将列表反转
#     reversed_nums = nums[::-1]
#     for num in reversed_nums:
#         total += num
#         suffix.append(total)
#     # 将结果反转回来
#     suffix.reverse()
#     return suffix
 
 
t = int(input())
ans = []
for _ in range(t):
    n, x = map(int, input().split())
    a = [int(i) for i in input().split()]


# Segment tree | Efficient implementation
# https://www.geeksforgeeks.org/segment-tree-efficient-implementation/

    # Max size of tree 
    tree = [0] * (2 * n); 

    def build(arr) : 

        # insert leaf nodes in tree 
        for i in range(n) : 
            tree[n + i] = arr[i]; 
        
        # build the tree by calculating parents 
        for i in range(n - 1, 0, -1) : 
            tree[i] = tree[i << 1] + tree[i << 1 | 1]; 

    # function to update a tree node 
    def updateTreeNode(p, value) : 
        
        # set value at position p 
        tree[p + n] = value; 
        p = p + n; 
        
        # move upward and update parents 
        i = p; 
        
        while i > 1 : 
            
            tree[i >> 1] = tree[i] + tree[i ^ 1]; 
            i >>= 1; 

    # function to get sum on interval [l, r) 
    def query(l, r) : 

        res = 0; 
        
        # loop to find the sum in the range 
        l += n; 
        r += n; 
        
        while l < r : 
        
            if (l & 1) : 
                res += tree[l]; 
                l += 1
        
            if (r & 1) : 
                r -= 1; 
                res += tree[r]; 
                
            l >>= 1; 
            r >>= 1
        
        return res; 
    #aprefix_sum = prefix_sum(a)
    #asuffix_sum = suffix_sum(a)
 
    build([i%x for i in a]);
    
    left = 0
    right = n - 1
    if right == 0:
        if a[0] % x !=0:
            print(1)
        else:
            print(-1)
        continue
 
    leftmax = 0
    rightmax = 0
    while left != right:
        #total = asuffix_sum[left]
        total = query(left, right+1)
        if total % x != 0:
            leftmax = right - left + 1
            break
        else:
            left += 1
 
    left = 0
    right = n - 1
    while left != right:
        #total = aprefix_sum[right]
        total = query(left, right+1)
        if total % x != 0:
            rightmax = right - left + 1
            break
        else:
            right -= 1
    
    if leftmax == 0 and rightmax == 0:
        #print(-1)
        ans.append(-1)
    else:
        #print(max(leftmax, rightmax))
        ans.append(max(leftmax, rightmax))

print('\n'.join(map(str,ans)))
```



如果用sum求和，O(n^2)，pypy3也会在test3 超时。



## 树状数组

树状数组或二叉索引树（英语：Binary Indexed Tree），又以其发明者命名为Fenwick树，最早由Peter M. Fenwick于1994年以A New Data Structure for Cumulative Frequency Tables为题发表。其初衷是解决数据压缩里的累积频率（Cumulative Frequency）的计算问题，现多用于高效计算数列的前缀和， 区间和。



### Binary Indexed Tree or Fenwick Tree

https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/

Let us consider the following problem to understand Binary Indexed Tree.
We have an array arr[0 . . . n-1]. We would like to 
**1** Compute the sum of the first i elements. 
**2** Modify the value of a specified element of the array arr[i] = x where 0 <= i <= n-1.
A **simple solution** is to run a loop from 0 to i-1 and calculate the sum of the elements. To update a value, simply do arr[i] = x. The first operation takes O(n) time and the second operation takes O(1) time. Another simple solution is to create an extra array and store the sum of the first i-th elements at the i-th index in this new array. The sum of a given range can now be calculated in O(1) time, but the update operation takes O(n) time now. This works well if there are a large number of query operations but a very few number of update operations.
**Could we perform both the query and update operations in O(log n) time?** 
One efficient solution is to use [Segment Tree](https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/) that performs both operations in O(Logn) time.
*An alternative solution is Binary Indexed Tree, which also achieves O(Logn) time complexity for both operations. Compared with Segment Tree, Binary Indexed Tree requires less space and is easier to implement.*.
**Representation** 
Binary Indexed Tree is represented as an array. Let the array be BITree[]. Each node of the Binary Indexed Tree stores the sum of some elements of the input array. The size of the Binary Indexed Tree is equal to the size of the input array, denoted as n. In the code below, we use a size of n+1 for ease of implementation.
**Construction** 
We initialize all the values in BITree[] as 0. Then we call update() for all the indexes, the update() operation is discussed below.
**Operations** 
 

> ***getSum(x): Returns the sum of the sub-array arr[0,…,x]*** 
> // Returns the sum of the sub-array arr[0,…,x] using BITree[0..n], which is constructed from arr[0..n-1] 
>
> 1) Initialize the output sum as 0, the current index as x+1. 
> 2) Do following while the current index is greater than 0. 
>
> …a) Add BITree[index] to sum 
> …b) Go to the parent of BITree[index]. The parent can be obtained by removing 
> the last set bit from the current index, i.e., index = index – (index & (-index)) 
>
> 3) Return sum.

 

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/BITSum.png" alt="BITSum" style="zoom: 67%;" />



The diagram above provides an example of how getSum() is working. Here are some important observations.
BITree[0] is a dummy node. 
BITree[y] is the parent of BITree[x], if and only if y can be obtained by removing the last set bit from the binary representation of x, that is y = x – (x & (-x)).
The child node BITree[x] of the node BITree[y] stores the sum of the elements between y(inclusive) and x(exclusive): arr[y,…,x). 
 

> ***update(x, val): Updates the Binary Indexed Tree (BIT) by performing arr[index] += val*** 
> // Note that the update(x, val) operation will not change arr[]. It only makes changes to BITree[] 
>
> 1) Initialize the current index as x+1. 
> 2) Do the following while the current index is smaller than or equal to n. 
>
> …a) Add the val to BITree[index] 
> …b) Go to next element of BITree[index]. The next element can be obtained by incrementing the last set bit of the current index, i.e., index = index + (index & (-index))

 

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/BITUpdate12.png" alt="BITUpdate1" style="zoom:67%;" />

The update function needs to make sure that all the BITree nodes which contain arr[i] within their ranges being updated. We loop over such nodes in the BITree by repeatedly adding the decimal number corresponding to the last set bit of the current index.
**How does Binary Indexed Tree work?** 
The idea is based on the fact that all positive integers can be represented as the sum of powers of 2. For example 19 can be represented as 16 + 2 + 1. Every node of the BITree stores the sum of n elements where n is a power of 2. For example, in the first diagram above (the diagram for getSum()), the sum of the first 12 elements can be obtained by the sum of the last 4 elements (from 9 to 12) plus the sum of 8 elements (from 1 to 8). The number of set bits in the binary representation of a number n is O(Logn). Therefore, we traverse at-most O(Logn) nodes in both getSum() and update() operations. The time complexity of the construction is O(nLogn) as it calls update() for all n elements. 
**Implementation:** 
Following are the implementations of Binary Indexed Tree.

```python
# Python implementation of Binary Indexed Tree 

# Returns sum of arr[0..index]. This function assumes 
# that the array is preprocessed and partial sums of 
# array elements are stored in BITree[]. 
def getsum(BITTree,i): 
	s = 0 #initialize result 

	# index in BITree[] is 1 more than the index in arr[] 
	i = i+1

	# Traverse ancestors of BITree[index] 
	while i > 0: 

		# Add current element of BITree to sum 
		s += BITTree[i] 

		# Move index to parent node in getSum View 
		i -= i & (-i) 
	return s 

# Updates a node in Binary Index Tree (BITree) at given index 
# in BITree. The given value 'val' is added to BITree[i] and 
# all of its ancestors in tree. 
def updatebit(BITTree , n , i ,v): 

	# index in BITree[] is 1 more than the index in arr[] 
	i += 1

	# Traverse all ancestors and add 'val' 
	while i <= n: 

		# Add 'val' to current node of BI Tree 
		BITTree[i] += v 

		# Update index to that of parent in update View 
		i += i & (-i) 


# Constructs and returns a Binary Indexed Tree for given 
# array of size n. 
def construct(arr, n): 

	# Create and initialize BITree[] as 0 
	BITTree = [0]*(n+1) 

	# Store the actual values in BITree[] using update() 
	for i in range(n): 
		updatebit(BITTree, n, i, arr[i]) 

	# Uncomment below lines to see contents of BITree[] 
	#for i in range(1,n+1): 
	#	 print BITTree[i], 
	return BITTree 


# Driver code to test above methods 
freq = [2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9] 
BITTree = construct(freq,len(freq)) 
print("Sum of elements in arr[0..5] is " + str(getsum(BITTree,5))) 
freq[3] += 6
updatebit(BITTree, len(freq), 3, 6) 
print("Sum of elements in arr[0..5]"+
					" after update is " + str(getsum(BITTree,5))) 

# This code is contributed by Raju Varshney 
 
```

**Output**

```
Sum of elements in arr[0..5] is 12
Sum of elements in arr[0..5] after update is 18
```

**Time Complexity:** O(NLogN)
**Auxiliary Space:** O(N)

**Can we extend the Binary Indexed Tree to computing the sum of a range in O(Logn) time?** 
Yes. rangeSum(l, r) = getSum(r) – getSum(l-1).
**Applications:** 
The implementation of the arithmetic coding algorithm. The development of the Binary Indexed Tree was primarily motivated by its application in this case. See [this ](http://en.wikipedia.org/wiki/Fenwick_tree#Applications)for more details.
**Example Problems:** 
[Count inversions in an array | Set 3 (Using BIT)](https://www.geeksforgeeks.org/count-inversions-array-set-3-using-bit/) 
[Two Dimensional Binary Indexed Tree or Fenwick Tree](https://www.geeksforgeeks.org/two-dimensional-binary-indexed-tree-or-fenwick-tree/) 
[Counting Triangles in a Rectangular space using BIT](https://www.geeksforgeeks.org/counting-triangles-in-a-rectangular-space-using-2d-bit/)

**References:** 
http://en.wikipedia.org/wiki/Fenwick_tree 
http://community.topcoder.com/tc?module=Static&d1=tutorials&d2=binaryIndexedTrees



### Two Dimensional Binary Indexed Tree or Fenwick Tree

https://www.geeksforgeeks.org/two-dimensional-binary-indexed-tree-or-fenwick-tree/

Prerequisite – [Fenwick Tree](https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/)
We know that to answer range sum queries on a 1-D array efficiently, binary indexed tree (or Fenwick Tree) is the best choice (even better than segment tree due to less memory requirements and a little faster than segment tree).
**Can we answer sub-matrix sum queries efficiently using Binary Indexed Tree ?**
The answer is **yes**. This is possible using a **2D BIT** which is nothing but an array of 1D BIT. 
**Algorithm:**
We consider the below example. Suppose we have to find the sum of all numbers inside the highlighted area- 
 

![fenwick tree](https://raw.githubusercontent.com/GMyhf/img/main/img/twodimensionalbinaryindexedtreea_k_afenwicktree.png)

We assume the origin of the matrix at the bottom – O.Then a 2D BIT exploits the fact that-
 

```
Sum under the marked area = Sum(OB) - Sum(OD) - 
                            Sum(OA) + Sum(OC) 
```

 



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/BOX86.jpg" alt="img" style="zoom:67%;" />

In our program, we use the getSum(x, y) function which finds the sum of the matrix from (0, 0) to (x, y). 
Hence the below formula : 
 

```
Sum under the marked area = Sum(OB) - Sum(OD) - 
                            Sum(OA) + Sum(OC) 

The above formula gets reduced to,

Query(x1,y1,x2,y2) = getSum(x2, y2) - 
                     getSum(x2, y1-1) - 
                     getSum(x1-1, y2) + 
                     getSum(x1-1, y1-1) 
```

where, 
**x1, y1** = x and y coordinates of C 
**x2, y2** = x and y coordinates of B
The updateBIT(x, y, val) function updates all the elements under the region – (x, y) to (N, M) where, 
**N** = maximum X co-ordinate of the whole matrix. 
**M** = maximum Y co-ordinate of the whole matrix.
The rest procedure is quite similar to that of 1D Binary Indexed Tree. Below is the implementation of 2D indexed tree 



```python
'''Python3 program to implement 2D Binary Indexed Tree 

2D BIT is basically a BIT where each element is another BIT. 
Updating by adding v on (x, y) means it's effect will be found 
throughout the rectangle [(x, y), (max_x, max_y)], 
and query for (x, y) gives you the result of the rectangle 
[(0, 0), (x, y)], assuming the total rectangle is 
[(0, 0), (max_x, max_y)]. So when you query and update on 
this BIT,you have to be careful about how many times you are 
subtracting a rectangle and adding it. Simple set union formula 
works here. 

So if you want to get the result of a specific rectangle 
[(x1, y1), (x2, y2)], the following steps are necessary: 

Query(x1,y1,x2,y2) = getSum(x2, y2)-getSum(x2, y1-1) - 
					getSum(x1-1, y2)+getSum(x1-1, y1-1) 

Here 'Query(x1,y1,x2,y2)' means the sum of elements enclosed 
in the rectangle with bottom-left corner's co-ordinates 
(x1, y1) and top-right corner's co-ordinates - (x2, y2) 

Constraints -> x1<=x2 and y1<=y2 

	/\ 
y | 
	|	 --------(x2,y2) 
	|	 | | 
	|	 | | 
	|	 | | 
	|	 --------- 
	| (x1,y1) 
	| 
	|___________________________ 
(0, 0)			 x--> 

In this program we have assumed a square matrix. The 
program can be easily extended to a rectangular one. '''

N = 4 # N-.max_x and max_y 

# A structure to hold the queries 
class Query:

	def __init__(self, x1,y1,x2,y2):
	
		self.x1 = x1;
		self.y1 = y1;
		self.x2 = x2;
		self.y2 = y2;


# A function to update the 2D BIT 
def updateBIT(BIT,x,y,val):
	
	while x <= N:
	
		# This loop update all the 1D BIT inside the 
		# array of 1D BIT = BIT[x] 
		while y <= N:
			BIT[x][y] += val;
			y += (y & -y)
		
		x += (x & -x)
	
	return; 


# A function to get sum from (0, 0) to (x, y) 
def getSum(BIT,x,y):

	sum = 0; 
	
	while x > 0:
		# This loop sum through all the 1D BIT 
		# inside the array of 1D BIT = BIT[x] 
		while y > 0:

			sum += BIT[x][y]; 
			y -= y&-y
		
		x -= x&-x
	
	return sum; 


# A function to create an auxiliary matrix 
# from the given input matrix 
def constructAux(mat,aux):
	# Initialise Auxiliary array to 0 
	for i in range(N + 1):
		for j in range(N + 1):
			aux[i][j] = 0

	# Construct the Auxiliary Matrix 
	for j in range(1, N + 1):
		for i in range(1, N + 1):
			aux[i][j] = mat[N - j][i - 1];

	return


# A function to construct a 2D BIT 
def construct2DBIT(mat,BIT):
	# Create an auxiliary matrix 
	aux = [None for i in range(N + 1)]
	for i in range(N + 1) : 
	
		aux[i]= [None for i in range(N + 1)]
	
	constructAux(mat, aux)

	# Initialise the BIT to 0 
	for i in range(1, N + 1): 
		for j in range(1, N + 1): 
			BIT[i][j] = 0; 

	for j in range(1, N + 1): 
	
		for i in range(1, N + 1): 
		
			# Creating a 2D-BIT using update function 
			# everytime we/ encounter a value in the 
			# input 2D-array 
			v1 = getSum(BIT, i, j); 
			v2 = getSum(BIT, i, j - 1); 
			v3 = getSum(BIT, i - 1, j - 1); 
			v4 = getSum(BIT, i - 1, j); 

			# Assigning a value to a particular element 
			# of 2D BIT 
			updateBIT(BIT, i, j, aux[i][j] -
					(v1 - v2 - v4 + v3)); 
		
	
	return; 


# A function to answer the queries 
def answerQueries(q,m,BIT):
	
	for i in range(m):
	
		x1 = q[i].x1 + 1; 
		y1 = q[i].y1 + 1; 
		x2 = q[i].x2 + 1; 
		y2 = q[i].y2 + 1; 

		ans = getSum(BIT, x2, y2) - \
				getSum(BIT, x2, y1 - 1) - \
				getSum(BIT, x1 - 1, y2) + \
				getSum(BIT, x1 - 1, y1 - 1); 

		print("Query (", q[i].x1, ", ", q[i].y1, ", ", q[i].x2, ", " , q[i].y2, ") = " ,ans, sep = "") 
	
	return; 


# Driver Code
mat= [[1, 2, 3, 4], 
					[5, 3, 8, 1], 
					[4, 6, 7, 5], 
					[2, 4, 8, 9]]; 

# Create a 2D Binary Indexed Tree 
BIT = [None for i in range(N + 1)]
for i in range(N + 1):

	BIT[i]= [None for i in range(N + 1)]
	for j in range(N + 1):
			BIT[i][j]=0
		
	
construct2DBIT(mat, BIT); 

''' Queries of the form - x1, y1, x2, y2 
	For example the query- {1, 1, 3, 2} means the sub-matrix- 
		y 
		/\ 
	3 | 1 2 3 4	 Sub-matrix 
	2 | 5 3 8 1	 {1,1,3,2} --.	 3 8 1 
	1 | 4 6 7 5								 6 7 5 
	0 | 2 4 8 9 
		| 
	--|------ 0 1 2 3 ---. x 
		| 
	
		Hence sum of the sub-matrix = 3+8+1+6+7+5 = 30 
	
	'''
q = [Query(1, 1, 3, 2), Query(2, 3, 3, 3), Query(1, 1, 1, 1)]; 
m = len(q)

answerQueries(q, m, BIT); 

# This code is contributed by phasing17

```



**Output**

```
Query(1, 1, 3, 2) = 30
Query(2, 3, 3, 3) = 7
Query(1, 1, 1, 1) = 6
```

**Time Complexity:** 
 

- Both updateBIT(x, y, val) function and getSum(x, y) function takes O(log(N)*log(M)) time.
- Building the 2D BIT takes O(NM log(N)*log(M)).
- Since in each of the queries we are calling getSum(x, y) function so answering all the Q queries takes **O(Q\*log(N)\*log(M))** time.

Hence the overall time complexity of the program is **O((NM+Q)\*log(N)\*log(M))** where, 
N = maximum X co-ordinate of the whole matrix. 
M = maximum Y co-ordinate of the whole matrix. 
Q = Number of queries.
**Auxiliary Space:** O(NM) to store the BIT and the auxiliary array
**References:** https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/







### 307.区域和检索 - 数组可修改

https://leetcode.cn/problems/range-sum-query-mutable/

给你一个数组 `nums` ，请你完成两类查询。

1. 其中一类查询要求 **更新** 数组 `nums` 下标对应的值
2. 另一类查询要求返回数组 `nums` 中索引 `left` 和索引 `right` 之间（ **包含** ）的nums元素的 **和** ，其中 `left <= right`

实现 `NumArray` 类：

- `NumArray(int[] nums)` 用整数数组 `nums` 初始化对象
- `void update(int index, int val)` 将 `nums[index]` 的值 **更新** 为 `val`
- `int sumRange(int left, int right)` 返回数组 `nums` 中索引 `left` 和索引 `right` 之间（ **包含** ）的nums元素的 **和** （即，`nums[left] + nums[left + 1], ..., nums[right]`）

 

**示例 1：**

```
输入：
["NumArray", "sumRange", "update", "sumRange"]
[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]
输出：
[null, 9, null, 8]

解释：
NumArray numArray = new NumArray([1, 3, 5]);
numArray.sumRange(0, 2); // 返回 1 + 3 + 5 = 9
numArray.update(1, 2);   // nums = [1,2,5]
numArray.sumRange(0, 2); // 返回 1 + 2 + 5 = 8
```



# Assignment #8

作业包括 recursion, greedy, matrices, dp 类型。
